//------------------------------------------------
//--- 010 Editor v10.0 Binary Template
//
//      File: Xray\GEOM.bt
//   Authors: TKGP
//   Version: 
//   Purpose: Xray level.geom files
//  Category: Xray
// File Mask: level.geom*
//  ID Bytes: 01 00 00 00 04 00 00 00 0E 00 00 00 09 00 00 00
//   History: 
//------------------------------------------------

#include "..\Util.bt"
#include "XrayUtil.bt"
#define FAST_VERTS

//------------------------------------------------

typedef struct {
    Block block(1);
    int unk00;
    Assert(FTell() == block.end);
} Header <bgcolor=cLtRed>;


typedef struct {
    short unk00;
    short offset;
    short type;
    byte semantic;
    byte index;
} BufferLayoutItem <read=ReadBufferLayoutItem>;

string ReadBufferLayoutItem(BufferLayoutItem& item) {
    string str;
    return SPrintf(str, "@%2Xh %2d %2d[%d]",
        item.offset, item.type, item.semantic, item.index);
}

typedef struct {
    local int count = 0;
    local int size = 0;
    while (ReadByte() != -1) {
        BufferLayoutItem items;
        switch (items.type) {
            case 2: size += 12; break;
            case 4: size += 4; break;
            case 6: size += 4; break;
            case 7: size += 8; break;
            default: Assert(false);
        }
        count++;
    }
} BufferLayout;


#ifdef FAST_VERTS

local int activeLayoutSize <hidden=true>;
typedef struct {
    ubyte data[activeLayoutSize];
} Vertex <bgcolor=cDkGreen, optimize=true>;

#else

typedef struct (BufferLayout& layout) {
    local int i <hidden=true>;
    for (i = 0; i < layout.count; i++) {
        switch (layout.items[i].semantic) {
            case 0:
                switch (layout.items[i].type) {
                    case 2: Vector3 position; break;
                    default: Assert(false);
                } break;

            case 3:
                switch (layout.items[i].type) {
                    case 4: int semantic3; break;
                    default: Assert(false);
                } break;

            case 5:
                switch (layout.items[i].type) {
                    case 6: int semantic5; break;
                    case 7: quad semantic5; break;
                    default: Assert(false);
                } break;

            case 6:
                switch (layout.items[i].type) {
                    case 4: int semantic6; break;
                    default: Assert(false);
                } break;

            case 7:
                switch (layout.items[i].type) {
                    case 4: int semantic7; break;
                    default: Assert(false);
                } break;

            case 10:
                switch (layout.items[i].type) {
                    case 4: int semantic10; break;
                    default: Assert(false);
                } break;

            default:
                Assert(false);
        }
    }
} Vertex <bgcolor=cDkGreen, optimize=true>;

#endif

typedef struct {
    BufferLayout bufferLayout;
    int unkX00; Assert(unkX00 == 0xFF);
    int unkX04; Assert(unkX04 == 0x11);
    int vertexCount;
    struct {
#ifdef FAST_VERTS
        activeLayoutSize = bufferLayout.size;
        Vertex vertices[vertexCount];
#else
        Vertex vertices(bufferLayout)[vertexCount];
#endif
    } vertices;
} VertexBuffer <bgcolor=cGreen, optimize=false>;

typedef struct {
    Block block(9);
    int bufferCount;
    VertexBuffer vertexBuffers[bufferCount];
    Assert(FTell() == block.end);
} Vertices <bgcolor=cLtGreen>;


typedef struct {
    int indexCount;
    ushort indices[indexCount] <bgcolor=cDkYellow>;
} IndexBuffer <bgcolor=cYellow, optimize=false>;

typedef struct {
    Block block(10);
    int bufferCount;
    IndexBuffer indexBuffers[bufferCount];
    Assert(FTell() == block.end);
} Indices <bgcolor=cLtYellow, optimize=false>;


typedef struct {
    int unk00;
    short unk04;
    short unk06;
} Struct3ChildItem <bgcolor=cDkPurple>;

typedef struct {
    int unk00;
    int unk04;
    int unk08;
    int unk0C;
    int itemCount;
    Struct3ChildItem items[itemCount];
} Struct3Child <bgcolor=cPurple, optimize=false>;

typedef struct {
    Block block(11);
    int childCount;
    if (childCount > 0) {
        struct { Struct3Child children[childCount]; } children;
    }
    Assert(FTell() == block.end);
} Struct3 <bgcolor=cLtPurple>;

//------------------------------------------------

Header header;
Vertices vertices;
Indices indices;
Struct3 struct3;
