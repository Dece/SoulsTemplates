//------------------------------------------------
//--- 010 Editor v9.0.1 Binary Template
//
//      File: MSB2\Part.bt
//   Authors: TKGP
//   Version: 
//   Purpose: DS2 map layout parts
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

enum <short> PartType {
    PartTypeMapPiece = 0,
    PartTypeObject = 1,
    //PartTypeEnemy = 2,
    PartTypeCollision = 3,
    PartTypeNavmesh = 4,
    PartTypeConnectCollision = 5,
};

struct PartMapPiece;
struct PartObject;
//struct PartEnemy;
struct PartCollision;
struct PartNavmesh;
struct PartConnectCollision;

typedef struct {
    local quad start <hidden=true> = FTell();

    quad nameOffset <format=hex>; Assert(nameOffset == 0x80);
    PartType type;
    short id;
    int modelIndex;
    Vector3 position;
    Vector3 rotation;
    Vector3 scale;
    uint drawGroupsMaybe[4];
    int unk44;
    int unk48;
    int unk4C;
    int unk50;
    uint dispGroupsMaybe[4];
    int unk64;
    int unk68;
    int unk6C;
    quad typeDataOffset <format=hex>;
    quad unk78; Assert(unk78 == 0);
    
    FSeek(start + nameOffset);
    wchar_t name[0x10];
    
    FSeek(start + typeDataOffset);
    switch (type) {
        case PartTypeMapPiece: PartMapPiece mapPiece; break;
        case PartTypeObject: PartObject object; break;
        //case PartTypeEnemy: PartEnemy enemy; break;
        case PartTypeCollision: PartCollision collision; break;
        case PartTypeNavmesh: PartNavmesh navmesh; break;
        case PartTypeConnectCollision: PartConnectCollision connectCollision; break;
    }
} Part <read=ReadPart>;

wstring ReadPart(Part& part) {
    string str;
    SPrintf(str, "%i %8X %8X %8X %8X %8X %8X %8X ",
        part.type, part.unk44, part.unk48, part.unk4C, part.unk50, part.unk64, part.unk68, part.unk6C);
    if (part.type == PartTypeMapPiece) {
        SPrintf(str, "%s %i %i %i", str, part.mapPiece.unk00, part.mapPiece.unk02, part.mapPiece.unk04);
    }    
    return str + part.name;
}


typedef struct {
    short unk00;
    short unk02;
    int unk04; Assert(unk04 == 0);
} PartMapPiece;


typedef struct {
    int unk00;
    int unk04;
    int unk08; Assert(unk08 == 0);
    int unk0C; Assert(unk0C == 0);
} PartObject;


typedef struct {
    byte b;
    /*int unk00; Assert(unk00 == 0);
    int unk04; Assert(unk04 == 0);
    int unk08;
    int unk0C;
    int unk10;
    short unk14; Assert(unk14 == 0);
    short unk16;
    int unk18;
    int unk1C;
    short unk20;
    short unk22;
    int unk24;
    int unk28; Assert(unk28 == -1);
    int unk2C; Assert(unk2C == -1);
    int unk30; Assert(unk30 == -1);
    int unk34; Assert(unk34 == -1);
    int unk38;
    int unk3C; Assert(unk3C == -1);
    int unk40;
    int unk44;
    int unk48;
    int unk4C;
    int unk50;
    int unk54; Assert(unk54 == 1);
    int unk58; Assert(unk58 == -1);
    int unk5C; Assert(unk5C == 1);
    int unk60; Assert(unk60 == 0);
    int unk64; Assert(unk64 == 0);
    int unk68; Assert(unk68 == 0);
    int unk6C; Assert(unk6C == 0);
    int unk70; Assert(unk70 == 0);
    int unk74; Assert(unk74 == 0);
    int unk78;
    int unk7C; Assert(unk7C == 0);
    int unk80; Assert(unk80 == 0);
    float unk84;
    int unk88; Assert(unk88 == -1);
    short unk8C; Assert(unk8C == -1);
    short unk8E; Assert(unk8E == 0xA);
    int unk90; Assert(unk90 == -1);
    short unk94; Assert(unk94 == -1);
    short unk96; Assert(unk96 == 0xA);
    int unk98; Assert(unk98 == -1);
    short unk9C; Assert(unk9C == -1);
    short unk9E; Assert(unk9E == 0xA);
    int unkA0; Assert(unkA0 == -1);
    short unkA4; Assert(unkA4 == -1);
    short unkA6; Assert(unkA6 == 0xA);
    int unkA8; Assert(unkA8 == -1);
    short unkAC; Assert(unkAC == -1);
    short unkAE; Assert(unkAE == 0xA);
    int unkB0; Assert(unkB0 == 0);
    int unkB4; Assert(unkB4 == 0);
    int unkB8; Assert(unkB8 == 0);
    int unkBC; Assert(unkBC == 0);*/
} PartEnemy;


typedef struct {
    int unk00;
    int unk04;
    int unk08;
    int unk0C;
    int unk10;
    int unk14;
    int unk18;
    int unk1C;
    int unk20;
    short unk24;
    short unk26;
    int unk28;
    int unk2C;
    int unk30;
    short unk34;
    short unk36;
    int unk38;
    int unk3C;
    int unk40;
    int unk44;
    int unk48;
    int unk4C;
    int unk50;
    int unk54;
} PartCollision;


typedef struct {
    int unk00;
    int unk04;
    int unk08;
    int unk0C;
    int unk10; Assert(unk10 == 0);
    int unk14; Assert(unk14 == 0);
    int unk18; Assert(unk18 == 0);
    int unk1C; Assert(unk1C == 0);
} PartNavmesh;


typedef struct {
    int collisionIndex;
    byte mapID[4];
    int unk08;
    int unk0C;
} PartConnectCollision;