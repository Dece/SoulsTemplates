//------------------------------------------------
//--- 010 Editor v7.0.2 Binary Template
//
//      File: FLVERD.bt
//   Authors: TKGP
//   Version: 
//   Purpose: Demon's Souls models
//  Category: Dark Souls
// File Mask: *.flver
//  ID Bytes: 46 4C 56 45 52 00 42 00 00 00 00
//   History: 
//------------------------------------------------

struct Vector3 {
    float x;
    float y;
    float z;
};

struct Header {
    char magic[6]; Assert(magic == "FLVER\0");
    char endian[2]; Assert(endian == "L\0" || endian == "B\0");
    if (endian == "L\0")
        LittleEndian();
    else
        BigEndian();
    int version; Assert(version >= 0x0E && version <= 0x15 && version != 0x11);
    int dataOffset <format=hex>;
    int dataSize <format=hex>;
    int dummyCount;
    int materialCount;
    int boneCount;
    int meshCount;
    int bufferCount; Assert(meshCount == bufferCount);
    Vector3 boundingBoxMin;
    Vector3 boundingBoxMax;
    int unk40 <format=hex>;
    int unk44 <format=hex>;
    int unk48 <format=hex>;
    int unk4C <format=hex>;
    int unk50 <hidden=true>; Assert(unk50 == 0);
    int unk54 <hidden=true>; Assert(unk54 == 0);
    int unk58 <hidden=true>; Assert(unk58 == 0);
    int unk5C <hidden=true>; Assert(unk5C == 0);
    int unk60 <hidden=true>; Assert(unk60 == 0);
    int unk64 <hidden=true>; Assert(unk64 == 0);
    int unk68 <hidden=true>; Assert(unk68 == 0);
    int unk6C <hidden=true>; Assert(unk6C == 0);
    int unk70 <hidden=true>; Assert(unk70 == 0);
    int unk74 <hidden=true>; Assert(unk74 == 0);
    int unk78 <hidden=true>; Assert(unk78 == 0);
    int unk7C <hidden=true>; Assert(unk7C == 0);
} header <bgcolor=cLtRed>;

typedef struct {
    int offset <hidden=true>;
    local quad pos = FTell();
    FSeek(offset);
    if (header.endian == "L\0")
        string str;
    else
        wstring str;
    FSeek(pos);
} OffsetString <read=OffsetStringRead>;

string OffsetStringRead(OffsetString &os) {
    return os.str;
};

if (header.dummyCount > 0) {
struct Dummy {
    Vector3 position;
    int unk0C; Assert(unk0C == -1);
    Vector3 forward;
    short referenceID;
    short dummyBoneIndex;
    Vector3 upward;
    short attachBoneIndex;
    byte flag1;
    byte flag2;
    int unk30; Assert(unk30 == 0);
    int unk34; Assert(unk34 == 0);
    int unk38; Assert(unk38 == 0);
    int unk3C; Assert(unk3C == 0);
} dummies[header.dummyCount] <bgcolor=cPurple, optimize=true>;
}

struct Texture {
    OffsetString path;
    OffsetString type;
    int unk08; Assert(unk08 == 0);
    int unk0C; Assert(unk0C == 0);
};

struct BufferMember {
    int unk00;
    int structOffset;
    int type;
    int semantic;
    int index;
};

struct BufferLayout {
    short memberCount;
    short structSize;
    int unkL04; Assert(unkL04 == 0);
    int unkL08; Assert(unkL08 == 0);
    int unkL0C; Assert(unkL0C == 0);
    BufferMember bufferMembers[memberCount];
};

struct Material {
    OffsetString name;
    OffsetString mtd;
    int texturesOffset <format=hex, hidden=true>;
    int bufferLayoutOffset <format=hex>;
    int dataSize <format=hex>; // From name offset to end of buffer layouts
    int bufferLayoutHeaderOffset <format=hex>;
    int unk18; Assert(unk18 == 0);
    int unk1C; Assert(unk1C == 0);

    local quad pos = FTell();
    FSeek(texturesOffset);
    byte textureCount;
    byte unkT01; Assert(unkT01 == 0);
    byte unkT02; Assert(unkT02 == 0);
    byte unkT03; Assert(unkT03 == 0);
    int unkT04; Assert(unkT04 == 0);
    int unkT08; Assert(unkT08 == 0);
    int unkT0C; Assert(unkT0C == 0);
    Texture textures[textureCount] <bgcolor=cAqua, optimize=false>;

    if (bufferLayoutHeaderOffset != 0) {
    FSeek(bufferLayoutHeaderOffset);
    int layoutCount;
    int unkB04; Assert(unkB04 == FTell() + 8);
    int unkB08; Assert(unkB08 == 0);
    int unkB0C; Assert(unkB0C == 0);
    int layoutOffsets[layoutCount];
    local int i;
    for (i = 0; i < layoutCount; i++) {
        FSeek(layoutOffsets[i]);
        BufferLayout bufferLayouts <bgcolor=cSilver>;
    }
    }
    FSeek(pos);
} materials[header.materialCount] <bgcolor=cLtBlue, optimize=false>;

struct Bone {
    Vector3 translation;
    OffsetString name;
    Vector3 rotation;
    short parentIndex;
    short childIndex;
    Vector3 scale;
    short nextSiblingIndex;
    short previousSiblingIndex;
    Vector3 boundingBoxMin;
    int nub; Assert(nub == 0);
    Vector3 boundingBoxMax;
    
    local int i;
    for (i = 0; i < 13; i++) {
        int pad <hidden=true>; Assert(pad == 0);
    }
} bones[header.boneCount] <bgcolor=cGray, optimize=false>;

struct Mesh {
    byte dynamic; Assert(dynamic == 0 || dynamic == 1);
    byte materialIndex;
    byte unk02;
    byte unk03;
    int vertexIndexCount;
    int vertexCount;
    short boneIndices[29] <bgcolor=cGreen>;
    short unk46; Assert(unk46 == 0);
    int vertexIndicesSize <format=hex>;
    int vertexIndicesOffset <format=hex>;
    int vertexBufferSize <format=hex>;
    int vertexBufferOffset <format=hex>;
    int vertexBufferHeaderOffset <format=hex>;
    int unk5C; Assert(unk5C == 0);
    int unk60; Assert(unk60 == 0);
    
    local quad pos = FTell();
    FSeek(header.dataOffset + vertexIndicesOffset);
    ushort vertexIndices[vertexIndexCount] <bgcolor=cYellow>;
    FSeek(header.dataOffset + vertexBufferOffset);
    byte vertexBuffer[vertexBufferSize] <bgcolor=cDkYellow>;
    FSeek(pos);
} meshes[header.meshCount] <bgcolor=cLtGreen, optimize=false>;