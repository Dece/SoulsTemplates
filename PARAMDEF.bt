//------------------------------------------------
//--- 010 Editor v7.0.2 Binary Template
//
//      File: PARAMDEF.bt
//   Authors: TKGP
//   Version: 
//   Purpose: 
//  Category: Dantelion
// File Mask: *.paramdef
//  ID Bytes: 
//   History: 
//------------------------------------------------

LittleEndian();
if (ReadByte(0x2C) == -1)
    BigEndian();

//------------------------------------------------

typedef struct {
    int fileSize <format=hex>;
    short unk04; Assert(unk04 == 0x30 || unk04 == 0xFF);
    short unk06; // Seen: 0, 1, 3
    short entryCount;
    short entrySize <format=hex>; Assert(entrySize == 0x6C || entrySize == 0x8C
        || entrySize == 0xAC || entrySize == 0xB0 || entrySize == 0xD0);

    char paramID[0x20] <bgcolor=cRed>;
    byte bigEndian; Assert(bigEndian == 0 || bigEndian == -1);
    byte unicode; Assert(unicode == 0 || unicode == 1);
    short version; Assert(version == 101 || version == 102 || version == 103
        || version == 104 || version == 201);

    if (version >= 201) {
        quad entriesStart <format=hex>; Assert(entriesStart == 0x38);
    }
} Header <bgcolor=cLtRed>;


typedef struct {
    if (header.unicode)
        wchar_t displayName[0x20] <bgcolor=cGreen>;
    else
        char displayName[0x40] <bgcolor=cGreen>;

    char displayType[0x8] <bgcolor=cGreen>;
    char displayFormat[0x8] <bgcolor=cGreen>;
    float defaultValue;
    float minValue;
    float maxValue;
    float increment;
    int editFlags; // 1 - Wrap, 4 - Lock
    int byteCount;
    
    if (header.version < 201)
        int descriptionOffset <format=hex>;
    else
        quad descriptionOffset <format=hex>;

    if (descriptionOffset != 0) {
        local quad pos <hidden=true> = FTell();
        FSeek(descriptionOffset);
        if (header.unicode)
            wstring description <bgcolor=cGreen>;
        else
            string description <bgcolor=cGreen>;
        FSeek(pos);
    }

    char internalType[0x20] <bgcolor=cGreen>;
    
    if (header.version >= 102) {
        char internalName[0x20] <bgcolor=cGreen>;
    }

    if (header.version >= 104) {
        int sortID;
    }

    if (header.version >= 201) {
        int unkB4 <hidden=true>; Assert(unkB4 == 0);
        int unkB8 <hidden=true>; Assert(unkB8 == 0);
        int unkBC <hidden=true>; Assert(unkBC == 0);
        int unkC0 <hidden=true>; Assert(unkC0 == 0);
        int unkC4 <hidden=true>; Assert(unkC4 == 0);
        int unkC8 <hidden=true>; Assert(unkC8 == 0);
        int unkCC <hidden=true>; Assert(unkCC == 0);
    }
} Entry <read=ReadEntry, bgcolor=cLtGreen, optimize=false>;

string ReadEntry(Entry& entry) {
    string str = entry.internalType;
    if (exists(entry.internalName))
        str += " - " + entry.internalName;
    str += " | " + entry.displayType + " - " + entry.displayName;
    return str;
}

//------------------------------------------------

Header header;
struct { Entry entries[header.entryCount]; } entries <open=true>;